    dewi - deploy and withdraw configuration files  |
----------------------------------------------------+

Dependencies.

    Dewi requires Perl5, a posix sh and a make implementation (GNU and
    BSD should both work).


Installation.

    For the most part, dewi works autonomous. If and where the files from
    this package are installed on a system does not matter to it. There
    is, however, a script called `dewi', too. It help with initialising
    and updating the `.dewi' directory in the parent directory and all
    dewi related Makefiles in that tree. So, basically you want to be
    able to do these operations:

        % dewi init
        % dewi update

    There are two ways of using this script. One is directly from this
    source package, the other is installing the source package to the
    system.


      I. From the source package

    To use the dewi script directly from the source package, you need to
    do this:

        % make

    Say the source package is located at `/usr/src/dewi-0.2', you would
    now use the script directly from there:

        % /usr/src/dewi-0.2/dewi <operation>

    That's all.


      II. Installation to the system.

    You can also install everything to the system like you would do
    with any other software package. These are the required steps:

        % make sys
        % make sysinstall

    After that the `dewi' script should be located in `/usr/local/bin'.
    If you would like another installation prefix, use:

        % make sys prefix=/my/preferred/prefix
        % make install prefix=/my/preferred/prefix


      III. Documentation

    The package also comes with documentation in form of txt2tags markup,
    from which manpages are generated. In order to generate and install
    these manpages, use these commands:

        % make doc
        % make docinstall


Usage.

    In order to put directory into a dewi context, you call the command
    `dewi init' from within that directory.

    After `init' the layout looks like this (assuming this is a directory
    that contains configuration files for applications in subdirectories,
    which is what dewi was designed for - let's assume `~/etc/'.):

        +-+-(~/etc/)
          |
          +-----(.dewi/)
          |
          +-----(Makefile)
          |
          +-----(emacs/)
          |
          +-----(fvwm/)
          |
          +-----(git/)
          |
          +-----(tmux/)
          |
          +-----(vim/)
          |
          \-----(zsh/)

    But actually, only the `.dewi' directory and the `Makefile' are
    special to dewi. You can have and sort of other content. Only when
    a subdirectory contains a `Dewifile' and a `Makefile', dawi starts
    to care.

    Let's say none of the subdirectories contain such files, yet. If
    you'd like to bootstrap the `emacs' subdirectory for use with dewi,
    you can simply do this:

        % make bs d=emacs

    And that's that. The layout will look something like this now:

        +---(root/)
          |
          +-----(.dewi/)
          |
          +-----(Makefile)
          |
          +--+--(emacs/)
          |  |
          |  +---------(Dewifile)
          |  |
          |  \---------(Makefile)
          |       .
          |       .
          |       .
          |       .
          |
          \-----(zsh/)

    With the `.dewi' subdirectory, the context is self-sufficient. You
    will *not* need the `dewi' tool at all. It's main use is to ease
    the setup and updating of the `.dewi' directory and the involved
    make files.


    When everything is set up correctly and a Dewifile is in place,
    you can just do:

        % make deploy

    to deploy the configuration, and

        % make withdraw

    to take it back.

    "make deploy" and "make withdraw" called in ~/etc deploys/withdraws
    all dewified subdirectories.


Example.

        TODO: Some of this should go into manual pages instead.


    First, put ~/etc into a dewi context:

        % cd ~/etc
        % dewi init

    Say you got your zsh configuration in ~/etc/zsh. To bootstrap that
    directory for dewi to (from ~/etc):

        % make bs d=zsh

    Say, ~/etc/zsh's layout looks like this:

        ~/etc/zsh/zshrc.d/*.z       - Sub configuration files
        ~/etc/zsh/zshrc             - The main configuration file, which
                                      loads the others.

    The corresponding Dewifile:

        register({ glob        => 'zshrc',
                   method      => 'copy',
                   destination => '~/',
                   transform   => sub { return '.' . $_[0]; }});
        register({ glob        => 'zshrc.d/*.z',
                   method      => 'copy',
                   destination => '~/.zshrc.d',
                   transform   => sub { return $_[0]; }});

    Some parts are optinal. Actually, all except for "glob" are optional.
    You could even just pass a scalar to `register', in which case that
    value is used as the `glob' part. So, if you'd have a file
    `~/etc/zsh/.zshrc' and only wanted to deploy that, you'd do:

        register('.zshrc');

    That means deploy the file `.zshrc' with default values for all other
    parameters. The defaults are:

        method          - copy
        destination     - ~/
        transform       - don't transform. Use the same names as the
                          ones that were globbed.

    There are some predefined functions to use for `transform', too:

        notransform     - Do not transform the globbed names. This is the
                          default transform.
        makedotfile     - Prefix the globbed name by a dot. Ie. `zshrc'
                          would be transformed into `.zshrc'.

    Possible values for `method' are:

        copy            - Copy file(s) if the destination is
                          older than the source.
        force_copy      - Copy file(s) regardless of age.
        hardlink        - Create hardlinks.
        symlink         - Create symlinks.

    If the `glob' parameter is a coderef, you can have absolute control
    over how filename generation is done. The coderef is expected to
    return a array of file names.

    With all that knowledge, the previous example can be boiled down to
    this:

        register({ glob        => 'zshrc',
                   transform   => \&makedotfile});
        register({ glob        => 'zshrc.d/*.z',
                   destination => '~/.zshrc.d', });

    Easy enough.

    Now suppose, you got a few files named `z*' instead of just `zshrc',
    like `zlogout', `zprofile', `zshenv' and `zshrc'. So, your layout
    not looks like this:

        ~/etc/zsh/zshrc.d/*.z       - Sub configuration files
        ~/etc/zsh/zshrc             - The main configuration file
        ~/etc/zsh/zshenv            - Some other file
        ~/etc/zsh/zprofile          - And another
        ~/etc/zsh/zlogout           - And a final one

    The problem here is that you cannot just glob for `z*' because that
    would match `zshrc.d', too, which is a directory.

    The trick is to use a coderef to do some filtering. When you use
    a coderef, you can use the `globarg' parameter to hand an argument
    to the coderef.

        sub glob_just_files {
            my ($glob) = @_;
            return grep { -f } bsd_glob($glob);
        }
        register({ glob        => \&glob_just_files,
                   globarg     => 'z*',
                   transform   => \&makedotfile});
        register({ glob        => 'zshrc.d/*.z',
                   destination => '~/.zshrc.d', });

    For convenience, dewi defines some coderefs for you. Well, currently
    only one:

        regular_files           - Like the default glob, but only
                                  match regular files. Expects `globarg'
                                  to be a string scalar which holds the
                                  desired glob. Like "*.txt".

    With that you can now do this:

        register({ glob        => \&regular_files,
                   globarg     => 'z*',
                   transform   => \&makedotfile});
        register({ glob        => 'zshrc.d/*.z',
                   destination => '~/.zshrc.d', });

    Neat, huh? :)
