DEWIFILE

Jul, 2010

%!target: man
%!postproc(man): "^(\.TH.*) 1 "  "\1 5 "


= NAME =
Dewifile - dewi(7) configuration


= DESCRIPTION =
Each subdirectory of a central dewi directory needs a files called
`//Dewifile//', which instructs which files are to be deployed (and
maybe later withdrawn, too) and how.

The `//Dewifile//' is a //Perl script// to allow for maximum control
of the process. It features a simple, yet powerful API for registering
files with dewi.


= API =
The API is quite simple. Mostly, you will be using the `//register()//'
and `//set_opt()//' functions. The latter for setting options, such as
`//debug//', `//verbose//' and `//dryrun//'. Below is a description of
the official API. There may be a number of functions available, that
start with two leading underscores. These functions are **not** meant
to be called by the user. These functions may not be useful to the user
and their behaviour may change.


== Main API ==
: **add_hook(** //HASHREF// **)**
Add a hook to an event. For details, see `HOOKS' in //dewi(7)//.

: **debug(** //PRINT_LIKE_ARGUMENTS// **)**
Like Perl's **print** subroutine, but only produces output if the
`//debug//' option is set.

: **deploy_directory(** //DIRECTORY_NAME// **)**
Register a directory name for creation during deployment and removal
during withdrawal (if the directory is empty during withdrawal, it is left
alone). This allows for the creation of empty directories during deployment.
\
The same expansions as with the //register()// function's `**destination**'
parameter is performed on the //DIRECTORY_NAME// argument.

: **dewifile_is_empty()**
Prints a message telling the user that the `//Dewifile//' needs to be
filled with suitable content. This is the function that is inserted
into the `//Dewifile//' created by "**dewi update**".

: **end()**
This function does nothing, but it returns a true value. You can use it
at the very end of a `//Dewifile//' so that Perl can source it without
errors and warnings.

: **expand_path(** //PATH// **)**
Perform tilde-expansion on **PATH**.

: **get_opt(** //OPTION_NAME// **)**
Returns the value of the option described by //OPTION_NAME//.

: **get_opt_bool(** //OPTION_NAME// **)**
Returns the value of the option described by //OPTION_NAME//, interpreted
as a boolean value (**no**, **no_thanks**, **off**, **false** and **0**
are interpreted as //false//; **yes**, **yes_please**, **on**, **true**
and **1** are interpreted as //true//. Other values are interpreted as
//false//, too, but will trigger a warning).

: **merge_path(** //PART_A//, //PART_B// **)**
Portably join **PART_A** and **PART_B** into a combined path name.

: **read_dewifile(** //PERL_SOURCE_FILE// **)**
With this, you can read files in addition to //Dewifile// and
//config.perl//. This may be useful if you want to include code like
example filters without pasting the whole code to either file.

: **register(** //HASHREF// | //STRING_SCALAR// **)**
This is the major file registration function. See `THE REGISTER FUNCTION'
below for details.

: **set_opt(** //OPTION_NAME//, //OPTION_VALUE// **)**
Set the option described by //OPTION_NAME// to the value //OPTION_VALUE//.

: **user_get(** //VARIABLE_NAME// **)**
Returns the value of the variable described by //VARIABLE_NAME// in the
user-variables namespace.

: **user_get_bool(** //VARIABLE_NAME// **)**
Like `//get_opt_bool()//', but for the user-variables namespace.

: **user_set(** //VARIABLE_NAME//, //VARIABLE_VALUE// **)**
Set the variable described by //VARIABLE_NAME// to the value
//VARIABLE_VALUE// in the user-variables namespace.


: **verbose(** //PRINT_LIKE_ARGUMENTS// **)**
Like Perl's **print** subroutine, but only produces output if the
`//verbose//' option is set.


== Predefined Destination Code ==
It is possible to pass a coderef as a value for the `register()//' function's
`**destination**' parameter. The `**destarg' parameter is passed as this
function's first argument. The second argument provided to this function is
a hashref containing information about each file in question. The following
keys are available:

: **path**
The entire source file name.

: **srcdir**
The directory part of the source file name.

: **name**
The file part of the source file name.

: **transformed**
The proposed file name part of the destination file. This is basically the
value of `//name//', but after all configured file name transformation code
has been run on it.

The destination coderef needs to return a **string** value, which will be
used as the destination directory for the currently processed file.


The following subroutines are available as `//destination//' callbacks in
Dewifiles per default:

: **recursive_dirname**
Constructs a multi-level destination directory from a given source file
name. This is useful to automatically register whole subtrees for
deployment in conjunction with `//recursivefiles()//' as a `**glob**'
callback (See //"Predefined Globbing Code"// below for details and an
example.)
\
This subroutine uses `//destarg//' as a root directory in which to put
the multi-level subtree (by concatenating the `**srcdir**' part from
its hashref argument to it).


== Predefined Globbing Code ==
These functions are to be used as coderef values to the `//register()//'
function's `**glob**' argument. The `**globarg**' parameter is passed to
the globbing function's first and only argument.

: **regularfiles(** //GLOB_STRING// **)**
Matches only regular files, that match //GLOB_STRING//.

: **recursivefiles(** (//HASH_REF//|//BASE_DIR_STRING//) **)**
Like `//regularfiles()//' but works recursively. The argument has to be a
hashref or a string. The hashref argument is the generic one. Two keys are
used: `//basedir//' and `//regex//'. `//basedir//' is the directory in which
file name generation should start. `//regex//' is a regular expression, each
generated file is matched against. Only if the regular expression matches
the file name, the file is used. **Note*: This is a **difference** between
this function and `//regularfiles()//', because `//regularfiles()//' uses
a shell globbing pattern *NOT* a Perl regular expression.
\
The default value for `//basedir//' is `//.//'. Meaning that the file
generation starts in the current directory.
\
For `//regex//' the default value is `//.//', which means that every file
generated will be matched.
\
If instead of a hashref, a string is given, it will be used as the value
for `//basedir//'. `//regex//' gets its default value.
\
Example:
\
```
    register({ glob        => \&recursivefiles,
               globarg     => { basedir => 'snippets',
                                regex   => '\.yasnippet$' },
               method      => 'copy',
               destination => \&recursive_dirname,
               destarg     => '~/.emacs.d'
               }});
```
\
See //"Predefined Destination Code"// above for details on
`//recursive_dirname()//' and `//destarg//'.


== Predefined Post-Glob Code ==
The functions described in this sub-section are supposed to be used as
coderef values to the `//register()//' function's `**post_glob**'
argument. If you need to use more than one, you can easily chain them
like this:
\
```
    register({ glob        => 'zshrc.d/*',
               method      => 'copy',
               destination => '~/.zshrc.d',
               post_glob   => sub {
                    return remove_hashes( remove_tilde(@_) );
               }});
```

: **remove_tilde**
Many editors create backup files in the form of **foo.txt~**. Using this
function as the //post_glob// parameter removes these files.

: **remove_hashes**
Some editors (like emacs) create files like **#foo.txt#** while running.
This function as the //post_glob// parameter removes these.


== Predefined Transform Code ==
These functions are meant to be used as coderef values of `//register()//'
function's `**transform**' argument. The file name in question is passed to
this the function's first and only argument.

: **makedotfile(** //INPUT_STRING// **)**
Prefixes the filename with a dot. For example `//foo//' turns into
`//.foo//'.

: **notransform(** //INPUT_STRING// **)**
Does no transformation at all. This is the default transformation.


= THE REGISTER FUNCTION =
The `//register()//' function is the main facility to tell **dewi** about
files it should deploy. It can be called in two ways: with a
**scalar string** as it's sole argument; and with a **hashref** as its
only argument which gives detailed control over how **dewi** will behave.

== hashref argument ==
The hashref call basically looks like this:
\
```
    register({ key0        => 'value0',
               key1        => 'value1',
               ...
               keyN        => "valueN"});
```

Possible keys are:

: **destination**
Where to put the files registered in this call. Defaults to the user's
home directory. If this parameter is a coderef, that code is executed to
construct a suitable destination directory for the file in question. See
//"Predefined Destination Code "// above for details on how that works.

: **filter**
If `//method//' is set to **filtered**, this specifies the filter, that
will be applied while deploying.
\
This can be either a string (in case the `//filtertype//' parameter is set
to either "**shell-file**" or "**shell-inline**") or a coderef (in case
`//filtertype//' is "**perl**").
\
See //FILTERING INPUT FILES// in //dewi(7)// for details.

: **filtertype**
This defines the type of filter that is being used if `//method//' is set
to **filtered**. See //FILTERING INPUT FILES// in //dewi(7)// for details.

: **glob**
This may either be a string or a coderef. If it is a string, it is used as
a globbing pattern to match certain files. If it is a coderef, the function
the reference points to is called with the **globarg** key's value as its
argument.

This is the only key that has **no default value**. It must be specified.

: **globarg**
If the **glob** key's value is a coderef, the value of this key is handed
over to the referenced function as its only argument.

: **post_glob**
This key's value may be a coderef to a subroutine that let's you modify the
list of files returned by the globbing mechanism. The referenced subroutine
gets all globbed file names as arguments and must return an array of file
names. This key has no default value.

: **transform**
The filename transformation is handled by the function referenced by this
key's value, which has to be a coderef. It defaults to a reference to
`//notransform//' which means, that no transformation is done per default.

: **method**
This key has to be a string which defined how the registered file should
be deployed by "**make deploy**". This defaults to `//copy//'. See
dewi(7) for details about the different possible methods.


A full example could look like this:
\
```
    register({ glob        => 'zshrc',
               method      => 'symlink',
               transform   => \&makedotfile});
```

== string argument ==
In **very** simple cases, you may only want to copy one file as a dotfile
to the user's home directory. In such a case, you may do this:
\
```
    register('zshrc');
```

That will use default values for all previously described keys, except for
`//transform//' which will be set to `//\&makedotfile//'. So, the above
register call will result in the file `//zshrc//' being **copied** to
`//~/.zshrc//'.


= OPTIONS =
: **debug**
Be very noisy during execution. This provides details during the execution
of the `//Dewifile//' as well as during the file deployment/withdrawal.
This defaults to `//false//'.

: **dryrun**
Run, but do not actually do anything. This is useful for writing Dewifiles
in connection with either the `//verbose//' or the `//debug//' option.
This defaults to `//false//'.

: **filter_always**
If set to `//true//', this will cause files that were registered using the
`**filtered**' method to **always** be remade no matter of their age. This
may be useful, when you are changing filter scripts and need to test a lot.
This defaults to `//false//'.

: **verbose**
Emit status messages during the file deployment/withdrawal.
This defaults to `//false//'.


= THE DEWI HASH =
Dewi sets up a hash that carries information which may be interesting when
writing filters and Perl hooks. The information provided by this hash is this:

: **BASE_DIR**
The name of the central directory. When `//~/etc/zsh//' is the packages
directory, this will be `//~/etc//'.

: **DOT_DEWI**
The path of the `.dewi' directory. This is `//BASE_DIR///.dewi'.

: **MAJOR_VERSION**
The major version of the running dewi program.

: **MINOR_VERSION**
The minor version of the running dewi program.

: **NAME**
The name of the program. This should better be `//dewi//'.

: **PACKAGE**
The name of the current package. When `//~/etc/zsh//' is the packages
directory, this will be `//zsh//'.

: **SUFFIX_VERSION**
The suffix version of the running dewi program. This is usually a `//+git//'
string when this dewi is not a released version.

: **VERSION**
This is just a concatenation of //MAJOR_VERSION//, //MINOR_VERSION// and
//SUFFIX_VERSION// with a dot in between of the first two parts.


= SEE ALSO =
dewi(7), dewi(1)


= COPYRIGHT =
Copyright (c) 2010-2011 Frank Terbeck <ft@bewatermyfriend.org>, All rights
reserved. Terms for redistribution and use can be found in doc/LICENCE.
