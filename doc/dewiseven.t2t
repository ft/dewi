DEWIFILE

Jul, 2010

%!target: man
%!postproc(man): "^(\.TH.*) 1 "  "\1 7 "


= NAME =
dewi - personal configuration file deploy/withdraw tool


= DESCRIPTION =
People often keep their important configuration files in a central place,
like `//~/etc//', where each sub-directory keeps the configuration files
for one application (often kept in distributed version control, like
//git//, //mercurial// or //bzr//).

So basically, the directories layout may look like this:
\
```
    +-+-(~/etc/)
      |
      +-----(emacs/)
      |
      +-----(fvwm/)
      |
      +-----(git/)
      |
      +-----(tmux/)
      |
      +-----(vim/)
      |
      \-----(zsh/)
```

Now, in order to use such configurations, their files need to be deployed
to the user's home directory. The file names may need to be changed, too.
For example, `//~/etc/zsh/zshrc//' needs to be deployed as `//~/.zshrc//'.

The idea to to be able to do the following:
\
```
    % cd ~/etc/zsh
    % make deploy
```

And have the zsh configuration files deployed to the user's home directory
automatically. A complementary make target `//withdraw//' may be used to
remove the previously deployed files from the home directory again.

It should also be possible to do ```make deploy``` in `//~/etc//' to
conveniently call the `//deploy//' target in all dewi-controlled
sub-directories.

In order to be able to do that, the dewi system must be made available in
the central directory. //dewi//(1) is the system's maintenance tool, which
is supposed to help the user to initialise and update the system's files
easily.

To initialise the system, you would do:
\
```
    % cd ~/etc
    % dewi init
```

That would add a `//.dewi//' sub-directory and a `//Makefile//', so now
the directory layout would look like this:

\
```
    +-+-(~/etc/)
      |
      +-----(.dewi/)
      |
      +-----(Makefile)
      |
      +-----(emacs/)
      |
      +-----(fvwm/)
      |
      +-----(git/)
      |
      +-----(tmux/)
      |
      +-----(vim/)
      |
      \-----(zsh/)
```

Not all sub-directories need to be dewi-controlled. In fact, only
directories, which contain a `//Dewifile//' and a `//Makefile//' are
considered by the system.

In order to create these files you need to "bootstrap" the subdirectory
like this (the `//emacs//' sub-directory in this case):
\
```
    % cd ~/etc
    % dewi add emacs
```
The layout will look something like this now:
\
```
    +---(root/)
        |
        +-----(.dewi/)
        |
        +-----(Makefile)
        |
        +--+--(emacs/)
        |  |
        |  +---------(Dewifile)
        |  |
        |  \---------(Makefile)
        |       .
        |       .
        |       .
        |       .
        |
        \-----(zsh/)
```

Now you need to fill the file `//~/etc/emacs/Dewifile//' with suitable
content, and then you will be able to use the `//deploy//' and
`//withdraw//' targets.

If you upgrade your copy of dewi and wish to update the .dewi directory
and the systems Makefiles, you can use the //dewi//(1) tool again:
\
```
    % cd ~/etc
    % dewi update
```


= DEPLOYMENT METHODS =
**dewi** is able to deploy configurations using different methods. The
default is `//copy//' which works with every filesystem.

Here is a list of supported methods:

: **copy**
Check whether the destination file is older than the source and if so,
copy the source file to its destination.

: **filtered**
If this method is used, the files selected in this register run are
subject to **filtering**. See //FILTERING INPUT FILES// in below for
details.

: **force_copy**
Like `//copy//', but does not check for age. It always copies all source
files.

: **hardlink**
Instead of copying, create hardlinks.

Note that this may cause problems if you are using version control for your
configuration files (like git with using `rebase').

: **symlink**
Instead of copying, create symbolic links.


= FILTERING INPUT FILES =
When deployed files need to carry information, which the input files don't
(such as passwords in your mail-retrieval configuration), you need to be
able to change contents on the fly. In //dewi// this is called **filtering**.

To apply filtering, you need set the `//method//' parameter of the register
function to **filtered** and supply a `//filter//' parameter, which will
further specify how the filtering will be done.

Filtering is only done if the destination file is younger than the source
file unless the `//filter_always//' option is set.

Filtering can be done in different ways, and specifying the `//filtertype//'
parameter of the register function will let you choose which:

: **perl**
With filtertype, the `//filter//' parameter must be a coderef that takes
exactly one scalar argument and returns a scalar. The argument will be the
currently processed line of the input file and the return value should be
that line with all your filters applied.
\
This is the **default** filtertype.

: **shell-file**
This type let's you define a filename as the `//filter//' parameter and
that file will be called as a shell script with the input file as **stdin**
and the deployed file's name as **stdout**.

: **shell-inline**
This is similar to the **shell-file** type, in the sense that the input
and output files are connected to **stdin** and **stdout** respectively.
But here, instead of a filename, the `//filter//' parameter may be any
chunk of shell code; **including** a single command. So if you feel like
filtering in **Python** or **Ruby**, you can do just that.


If you are using **perl** filter subroutines, you can obviously just
bail out of the current dewi run by just exiting. If you want to do that
with the other filtertypes, you can do that by sending a signal to the
parent process:

: **SIGHUP**
When //dewi// receives this, it exists and returns a successful value
(i.e. `**make**' will not be stopped).

: **SIGINT**
When this signal is received, it exists and returns failure. This will also
stop running `**make**' targets, like `//deploy//'.


= EXAMPLE =
Let's assume, the configuration file directory is `//~/etc//' and we want
to deploy our zsh configuration which is located in the `//zsh//'
sub-directory.

First, put ~/etc into a dewi context:
\
```
    % cd ~/etc
    % dewi init
```

Say you got your zsh configuration in ~/etc/zsh. To bootstrap that
directory for dewi to (from ~/etc):
\
```
    % dewi add zsh
```

Say, ~/etc/zsh's layout looks like this:

: **~/etc/zsh/zshrc.d/*.z**
Sub configuration files

: **~/etc/zsh/zshrc**
The main configuration file, which loads the others.


The corresponding Dewifile:
\
```
    register({ glob        => 'zshrc',
               method      => 'copy',
               destination => '~/',
               transform   => sub { return '.' . $_[0]; }});
    register({ glob        => 'zshrc.d/*.z',
               method      => 'copy',
               destination => '~/.zshrc.d',
               transform   => sub { return $_[0]; }});
```

Some parts are optinal. Actually, all except for "glob" are optional.
You could even just pass a scalar to `register', in which case that
value is used as the `glob' part. So, if you'd have a file
`~/etc/zsh/zshrc' and only wanted to deploy that, you'd do:
\
```
    register('zshrc');
```

That means deploy the file `zshrc' with default values for all other
parameters, except for `//transform//' which will be set to a reference
to `//makedotfile//'. That way the above line would deploy the file as
`//~/.zshrc//'.

If the `glob' parameter is a coderef, you can have absolute control
over how filename generation is done. The coderef is expected to
return a array of file names.

With all that knowledge, the previous example can be boiled down to
this:
\
```
    register('zshrc');
    register({ glob        => 'zshrc.d/*.z',
               destination => '~/.zshrc.d', });
```

Easy enough.

Now suppose, you got a few files named `z*' instead of just `zshrc',
like `zlogout', `zprofile', `zshenv' and `zshrc'. So, your layout
not looks like this:

: **~/etc/zsh/zshrc.d/*.z**
Sub configuration files
: **~/etc/zsh/zshrc**
The main configuration file
: **~/etc/zsh/zshenv**
Some other file
: **~/etc/zsh/zprofile**
And another
: **~/etc/zsh/zlogout**
And a final one

The problem here is that you cannot just glob for `z*' because that
would match `zshrc.d', too, which is a directory.

The trick is to use a coderef to do some filtering. When you use
a coderef, you can use the `globarg' parameter to hand an argument
to the coderef.
\
```
    sub glob_just_files {
        my ($glob) = @_;
        return grep { -f } bsd_glob($glob);
    }
    register({ glob        => \&glob_just_files,
               globarg     => 'z*',
               transform   => \&makedotfile});
    register({ glob        => 'zshrc.d/*.z',
               destination => '~/.zshrc.d', });
```


For convenience, dewi defines some coderefs for you. Well, currently
only one:

: **regularfiles**
Like the default glob, but only match regular files. Expects `globarg'
to be a string scalar which holds the desired glob. Like "*.txt".

With that you can now do this:
\
```
    register({ glob        => \&regular_files,
               globarg     => 'z*',
               transform   => \&makedotfile});
    register({ glob        => 'zshrc.d/*.z',
               destination => '~/.zshrc.d', });
```


For more details and documentation of the full `//Dewifile//' API, see
the dewifile(5) manual page.


= SEE ALSO =
dewi(1), dewifile(5)


= COPYRIGHT =
Copyright (c) 2010 Frank Terbeck <ft@bewatermyfriend.org>, All rights
reserved. Terms for redistribution and use can be found in doc/LICENCE.
