#!/usr/bin/perl
# Copyright (c) 2010-2011
# Frank Terbeck <ft@bewatermyfriend.org>, All rights reserved.
# Terms for redistribution and use can be found in `LICENCE'.

###########################################################################
package DewiFile;

use strict;
use warnings qw(all);
use English '-no_match_vars';
use File::Glob qw{ bsd_glob };
use File::Spec;
use File::Basename;

my $reg_calls = 0;
our (%DEWI);

# user definable settings
my (%user_settings);
sub user_set {
    my ($key, $val) = @_;
    $user_settings{$key} = $val;
}

sub user_get {
    my ($key) = @_;
    return $user_settings{$key};
}

sub user_get_bool {
    my ($key) = @_;
    return main::__get_opt_bool(\&user_get, $key);
}

# output
sub verbose {
    main::verbose(@_);
    return 1;
}

sub debug {
    main::debug(@_);
    return 1;
}

# option handling
sub set_opt {
    my ($key, $val) = @_;

    main::set_opt($key, $val);
    print "rc.perl: Set option '$key' to \"$val\"\n"
        if (main::get_opt_bool('debug'));
    return 1;
}

sub get_opt {
    return main::get_opt(@_);
}

sub get_opt_bool {
    return main::get_opt_bool(@_);
}

# helpers
# hooks
sub add_hook {
    my ($h) = @_;
    my ($ev);

    goto ERROR if (ref($h) ne 'HASH');
    $h->{type} = 'perl' if (!defined $h->{type});
    goto ERROR if (!defined $h->{code} || !defined $h->{event});
    if ($h->{type} ne 'perl' && $h->{type} ne 'shell-inline'
            && $h->{type} ne 'shell-file')
    {
        print "The type parameter needs to be one of these:\n";
        print "  - perl\n";
        print "  - shell-file\n";
        print "  - shell-inline\n";
        print "\n";
        goto ERROR;
    }
    if ($h->{type} eq 'perl' && ref($h->{code}) ne 'CODE') {
        print "add_hook(): When `type' is \"perl\","
            . " `code' needs to be a coderef.\n\n";
        goto ERROR;
    }
    if ($h->{type} eq 'shell-file' && !-f ref($h->{code})) {
        print "add_hook(): When `type' is \"shell-file\","
            . " `code' needs to be an existing file.\n\n";
        goto ERROR;
    }
    $ev = $h->{event};
    delete($h->{event});
    main::register_hook($ev, $h);
    return 1;

ERROR:
    print "usage: add_hook(<hash-ref>);\n";
    print "See dewifile(5) for details.\n";
    exit 1;
}

# archiving
sub tar {
    my ($dest) = @_;

    if (defined $main::archives{tar}) {
        die "Already defined tarball: " . $main::archives{tar} . "\n";
    }
    $dest =~ s/\/+$//;
    $main::archives{tar} = $dest;
}

sub tar_gz {
    my ($dest) = @_;

    if (defined $main::archives{'tar-gz'}) {
        die "Already defined tarball: " . $main::archives{'tar-gz'} . "\n";
    }
    $dest =~ s/\/+$//;
    $main::archives{'tar-gz'} = $dest;
}

sub tar_bz2 {
    my ($dest) = @_;

    if (defined $main::archives{'tar-bz2'}) {
        die "Already defined tarball: " . $main::archives{'tar-bz2'} . "\n";
    }
    $dest =~ s/\/+$//;
    $main::archives{'tar-bz2'} = $dest;
}

# request empty directories
sub deploy_directory {
    if ($#_ != 0) {
        die "usage: deploy_directory('directory_name');\n";
    }
    my ($dir) = @_;

    my $new = {};
    $new->{destination} = main::expand_dir($dir);
    $new->{deploydir} = 'yes';
    debug("deploy_directory(): \"" . $new->{destination} . "\"\n");
    push @main::regfiles, $new;
}

# predefined `glob' code
sub regularfiles {
    my ($glob) = @_;

    return grep { -f } bsd_glob($glob);
}

# predefined `post-glob' code
sub remove_tilde {
    # throw away stuff that matches "*~"
    my (@ret);

    foreach my $file (@_) {
        if ($file !~ m/~$/) {
            push @ret, $file
        } else {
            debug("Weeding out backup file: `$file'\n");
        }
    }

    return @ret;
}

sub remove_hashes {
    # throw away stuff that matches "#*#"
    my (@ret);

    foreach my $file (@_) {
        my $name = basename($file);
        if ($name !~ m/^#.+#$/) {
            push @ret, $file
        } else {
            debug("Weeding out temporary file: `$file'\n");
        }
    }

    return @ret;
}

# predefined `transform' code
sub notransform {
    return $_[0];
}

sub makedotfile {
    return '.' . $_[0];
}

# path name helpers
sub merge_path {
    if ($#_ != 1) {
        die "Usage: merge_path(<part_one>, <part_two>);\n";
    }
    main::merge_name(@_);
}

sub expand_path {
    if ($#_ != 0) {
        die "Usage: merge_path(<directory>);\n";
    }
    main::expand_dir(@_);
}

# The `register()' subroutine
sub __register_defaults {
    # This sets default values for the different meaningful keys and
    # also does some error-checking on values where it makes sense.
    my ($h) = @_;

    if (!defined $h->{glob}) {
        die "Cannot call register() without `glob' argument.\n";
    }
    if (ref($h->{glob}) eq 'CODE' && !defined &{ $h->{glob} }) {
        die
        "register(): Unknown coderef in `glob'.\n".
        "                        Call number $reg_calls.\n";
    }

    if (!defined $h->{destination}) {
        $h->{destination} = '~/';
        debug("register(): Setting default `destination': ~/\n");
    }

    if (!defined $h->{method}) {
        $h->{method} = 'copy';
        debug("register(): Setting default `method': copy\n");
    }
    if (!main::method_exists($h->{method})) {
        die
        "register(): Unknown `method' parameter: \"" . $h->{method} . "\"\n".
        "                        Call number $reg_calls.\n";
    }

    if (!defined $h->{transform}) {
        $h->{transform} = \&notransform;
        debug("register(): Setting default `transform': `notransform'\n");
    }

    if (!defined &{ $h->{transform} }) {
        die
        "register(): Unknown coderef in `transform'.\n".
        "                        Call number $reg_calls.\n";
    }

    if (defined $h->{post_glob} && !defined &{ $h->{post_glob} }) {
        die
        "register(): Unknown coderef in `post_glob'.\n".
        "                        Call number $reg_calls.\n";
    }

    if (!defined $h->{globarg}) {
        $h->{globarg} = '';
        debug("register(): Setting default `globarg': (empty string)\n");
    }

    if ($h->{method} eq 'filtered') {
        if (!defined $h->{filtertype}) {
            $h->{filtertype} = 'perl';
        }
        if (!defined $h->{filter}) {
            die "register(): `filter' undefined with `filtered' method.\n".
                "                        Call number $reg_calls.\n";
        }
        if ($h->{filtertype} eq 'perl' && !defined &{ $h->{filter} }) {
            die "register(): perl filter: Unknown coderef.\n".
                "                        Call number $reg_calls.\n";
        }
        if ($h->{filtertype} eq 'shell-file' && !-e $h->{filter}) {
            die "register(): shell-file filter: File does not exist `" .
                $h->{filter} . "'.\n".
                "                        Call number $reg_calls.\n";
        }
    }

    return 1;
}

sub __register {
    my ($h) = @_;
    my (@files);

    if (ref($h->{glob}) eq 'CODE') {
        @files = $h->{glob}->($h->{globarg});
    } else {
        @files = bsd_glob($h->{glob});
    }
    if (defined $h->{post_glob} && ref $h->{post_glob} eq 'CODE') {
        @files = $h->{post_glob}->(@files);
    }

    $h->{destination} = main::expand_dir($h->{destination});
    foreach my $path (@files) {
        my $new = {};
        my ($volume,$directories,$file) = File::Spec->splitpath( $path );

        $new->{path} = $path;
        $directories =~ s/\/+$//;
        $new->{srcdir} = $directories;
        $new->{name} = $file;
        $new->{transformed} = $h->{transform}->($file);
        $new->{destination} = $h->{destination};
        $new->{mergedname} =
        main::merge_name($h->{destination}, $new->{transformed});
        $new->{method} = $h->{method};
        $new->{filter} = $h->{filter};
        $new->{filtertype} = $h->{filtertype};

        debug(
            "register(): \""      . $new->{path}        . "\"\n" .
            "           Name: \"" . $new->{name}        . "\"\n" .
            "    Transformed: \"" . $new->{transformed} . "\"\n" .
            "         Source: \"" . $new->{srcdir}      . "\"\n" .
            "    Destination: \"" . $new->{destination} . "\"\n" .
            "    Merged-Name: \"" . $new->{mergedname}  . "\"\n" .
            "         Method: "   . $new->{method}      . "\n");

        push @main::regfiles, $new;
    }

    return 1;
}

sub register {
    $reg_calls++;
    if ($#_ != 0) {
        die "usage: register( { foo => val0, bar => val1, ... } );\n";
    }
    my ($arg) = @_;
    my $type = ref $arg;

    if ($type eq '') {
        my $hr = { glob      => "$arg",
                   transform => \&makedotfile};
        __register_defaults($hr);
        __register($hr);
    } elsif ($type eq 'HASH') {
        __register_defaults($arg);
        __register($arg);
    } else {
        die
        "The argument to the register function must be either a\n".
        "scalar or a hash reference.\n";
    }

    return 1;
}

# Dewifile reader
sub read_dewifile {
    my ($file) = @_;
    my ($d, $rc);

    $rc = do $file;
    if (!defined $rc && $EVAL_ERROR) {
        warn qq{Could not parse $file:\n  - Reason: $@\n};
        return 0;
    } elsif (!defined $rc) {
        if ($@ eq '') {
            warn qq{$file empty?\n};
        } else {
            warn qq{Could not read $file:\n  - Reason: $!\n};
        }
        return 0;
    } elsif ($rc != 1) {
        warn qq{Reading $file did not return 1.\n}
        ."  While this is not a fatal problem, it is good practice, to let\n"
        ."  perl script files return 1. Just put a '1;' into the last line\n"
        ."  of this file to get rid of this warning.\n";
    }

    return 1;
}

# place holder function for the bootstrapping functionality
sub dewifile_is_empty {
    print
"This Dewifile is empty. Is was probably created by dewi's bootstrap mode.\n".
"You will need to register the files you want dewi to deploy. This is\n".
"merely a placeholder.   Thanks for your attention.\n";
}

# a glorified '1;' for the end of Dewifiles
sub end {
    return 1;
}

###########################################################################
package main;

use strict;
use warnings qw(all);
use English '-no_match_vars';
use Cwd;
use File::Basename;
use File::Copy;
use File::Spec;

my %optional_features = (
    external_filters => "tobeseen"
);

eval {require IPC::Run3;};
if ($@) {
    $optional_features{external_filters} = 'missing';
} else {
    $optional_features{external_filters} = 'gotit';
}

our $NAME = 'dewi';
our $MAJOR_VERSION = 0;
our $MINOR_VERSION = 2;
our $SUFFIX_VERSION = '+git';
our $VERSION = $MAJOR_VERSION . '.' . $MINOR_VERSION . $SUFFIX_VERSION;

my (%opts);
our (%hooks, %archives, @regfiles);

my %methods = (
    copy       => \&method_copy,
    filtered   => \&method_filtered,
    force_copy => \&method_force_copy,
    hardlink   => \&method_hardlink,
    symlink    => \&method_symlink
);

sub method_exists {
    my ($method) = @_;

    if (defined $methods{$method}) {
        return 1;
    }
    return 0;
}

sub dewi_got_feature {
    my ($f) = @_;

    if (defined $optional_features{$f} && $optional_features{$f} eq 'gotit') {
        return 1;
    }
    return 0;
}

# output
sub verbose {
    print @_ if (get_opt_bool('verbose') || get_opt_bool('debug'));
    return 1;
}

sub debug {
    print @_ if (get_opt_bool('debug'));
    return 1;
}

# option handling
sub defaults {
    set_opt('filter_always', 'no');
    set_opt('debug',         'no');
    set_opt('dryrun',        'no');
    set_opt('verbose',       'no');
}

sub get_opt {
    my ($key) = @_;
    return $opts{$key};
}

sub __get_opt_bool {
    my ($go, $key) = @_;
    my ($v);

    $v = $go->($key);
    return 0 if (!defined $v || $v eq 'no' || $v eq 'no_thanks' || $v eq 'off'
        || $v eq 'false' || $v eq '0');
    return 1 if ($v eq 'yes' || $v eq 'yes_please' || $v eq 'on'
        || $v eq 'true' || $v eq '1');

    warn "Unknown value for boolean option \"$key\" ($v). Assuming false.\n";
    return 0;
}

sub get_opt_bool {
    my ($key) = @_;
    return __get_opt_bool(\&get_opt, $key);
}

sub set_opt {
    my ($key, $val) = @_;
    $opts{$key} = $val;
}

# setup the DEWI hash
sub set_dewi_hash {
    %DewiFile::DEWI = (
        NAME           => $NAME,
        MAJOR_VERSION  => $MAJOR_VERSION,
        MINOR_VERSION  => $MINOR_VERSION,
        SUFFIX_VERSION => $SUFFIX_VERSION,
        VERSION        => $VERSION,
        BASE_DIR       => base_dir(),
        DOT_DEWI       => dot_dewi(),
        PACKAGE        => dewi_package()
    );
}

sub base_dir {
    return Cwd::abs_path(basename(Cwd::getcwd() . "/.."))
}

sub dot_dewi {
    my $base = base_dir();
    my $dd = "$base/.dewi";

    if (! -d $dd) {
        die "No .dewi in '$base'. Giving up.\n";
    }

    return $dd;
}

sub dewi_package {
    return basename(Cwd::abs_path(Cwd::getcwd()));
}

# help the user
sub help_header {
    print
"  +-------------------------------------------------+\n".
"  | dewi - deploy and withdraw configuration files  |\n".
"  +-------------------------------------------------+\n";
}

sub help_footer {
    print
"\n".
"Other targets may be available if a `local_dewi.mk' file exists.\n";
}

sub parent_help {
    help_header();
    print
"\n".
"Built-in make targets:\n".
"    deploy    - Deploy files from every subdirectory that has\n".
"                a working dewi setup.\n".
"    withdraw  - Withdraw files from every subdirectory with a\n".
"                working dewi setup.\n".
"    update    - Update the dewi-related Makefiles.\n".
"    all       - Display this help text.\n";
    help_footer();
}

sub child_help {
    help_header();
    print
"\n".
"Built-in make targets:\n".
"    deploy    - Deploy the files as configured in `Dewifile'.\n".
"    withdraw  - Remove the configured files from their deployment places.\n".
"    all       - Display this help text.\n";
    help_footer();
}

# utilities
sub expand_dir {
    my ($str) = @_;

    $str =~ s!^~!$ENV{HOME}!;
    $str =~ s/\/+$//;
    return $str;
}

sub run_dot_dewi_script {
    my ($script, @args) = @_;
    my (@cmd, $rc);

    if (get_opt_bool('dryrun')) {
        return 0;
    }
    @cmd = ('@@POSIX_SH@@', $DEWI{DOT_DEWI} . $script);
    push @cmd, @args if ($#args >= 0);
    system @cmd;
    $rc = $?;

    if ($rc == -1) {
        die "run_dot_dewi_script(): `system()' failed!\n";
    }
    return $rc;
}

sub xcopy {
    my ($src, $dst) = @_;

    if (get_opt_bool('dryrun')) {
        return 1;
    }
    copy($src, $dst) or die "copy($src, $dst) failed: $!\n";
    return 1;
}

sub xdir_is_empty {
    my ($dir) = @_;
    my ($dh);

    opendir $dh, $dir or die "xdir_is_empty(): Could not open $dir: $!\n";
    if (scalar(grep(!/^\.\.?$/, readdir($dh)) == 0)) {
        closedir $dh;
        return 1;
    }
    closedir $dh;
    return 0;
}

sub xhardlink {
    my ($src, $dst) = @_;

    if (get_opt_bool('dryrun')) {
        return 1;
    }

    link Cwd::realpath($src), $dst
        or die "Could not create hardlink: $!\n";
}

sub xrmdir {
    # Assumes that it is never called in dryrun mode.
    my ($dir) = @_;

    rmdir $dir or die "rmdir() failed: $!\n";
}

sub xsymlink {
    my ($src, $dst) = @_;

    if (get_opt_bool('dryrun')) {
        return 1;
    }

    if (-l $dst) {
        # if we're here, $dst exists, is a symlink but links somewhere
        # else. Remove it, so the symlink() below can succeed.
        xunlink($dst);
    }
    symlink Cwd::realpath($src), $dst
        or die "Could not create symlink: $!\n";
}

sub stat_names {
    my ($num) = @_;
    my @names = qw{ dev ino mode nlink uid gid rdev size
                    atime mtime ctime blksize blocks };

    return $names[$num];
}

sub xstat {
    my ($file) = @_;
    my ($i, %stat, @data);

    @data = stat($file);
    $i = 0;
    %stat = map { stat_names($i++) => $_ } @data;
    if (-e _) {
        $stat{exist} = 1;
    } else {
        $stat{exist} = 0;
    }

    $stat{plainfile} = 0;
    $stat{dir} = 0;
    if (-f _) {
        $stat{plainfile} = 1;
    } elsif (-d _) {
        $stat{dir} = 1;
    }
    return \%stat;
}

sub xunlink {
    my ($file) = @_;

    if (get_opt_bool('dryrun')) {
        return 1;
    }

    unlink $file or die "unlink() failed: $!\n";
}

sub ensure_dir {
    # think: mkdir -p /foo/bar/baz
    my ($wantdir) = @_;
    my (@parts, $sofar);

    if (-d $wantdir) {
        return 1;
    }

    if ($wantdir =~ q{^/}) {
        $sofar = q{/};
    } else {
        $sofar = q{};
    }

    @parts = split /\//, $wantdir;
    foreach my $part (@parts) {
        if ($part eq q{}) {
            next;
        }
        $sofar = (
                  $sofar eq q{}
                    ? $part
                    : (
                        $sofar eq q{/}
                          ? q{/} . $part
                          : $sofar . q{/} . $part
                      )
                 );

        if (!-d $sofar) {
            if (!get_opt_bool('dryrun')) {
                verbose("  _mkdir(): $sofar\n");
                mkdir $sofar
                    or die "Could not mkdir($sofar).\n" . "Reason: $!\n";
            }
        }
    }

    return 1;
}

# aaaand ACTION.
sub merge_name {
    my ($dest, $file) = @_;
    return File::Spec->catfile($dest, $file);
}

sub method_copy {
    my ($src, $dst, $dummy0, $dummy1) = @_;
    my ($dstat, $sstat);

    $sstat = xstat($src);
    $dstat = xstat($dst);
    if (($dstat->{exist} == 1) && ($sstat->{ino} == $dstat->{ino})) {
        die "  _copy(): $src and $dst are the same file. Please resolve!\n";
    }
    if (($dstat->{exist} == 1) && ($sstat->{mtime} <= $dstat->{mtime})) {
        verbose("  _copy(): $dst (source is not newer, skipping)\n");
        debug("   source: $src\n");
        return 1;
    }
    verbose("  _copy(): $dst\n");
    debug("   source: $src\n");
    xcopy($src, $dst);
}

sub __filter_perl {
    my ($filter, $src, $dst) = @_;
    my ($in, $out);

    return 1 if (get_opt_bool('dryrun'));
    open $in, "<", $src or die "Could not open `$src': $!\n";
    open $out, ">", $dst or die "Could not open `$dst': $!\n";

    while (my $line = <$in>) {
        chomp $line;
        $line = $filter->($line);
        print {$out} "$line\n";
    }

    close $out;
    close $in;
}

sub __filter_shell_file {
    my ($filter, $src, $dst) = @_;
    my ($cmd);

    if (!dewi_got_feature('external_filters')) {
        print "Cannot run `shell-file' filter as required.\n";
        print "This dewi has no support for external filters. Giving up.\n";
        return 1;
    }
    return 1 if (get_opt_bool('dryrun'));
    $cmd = [ '@@POSIX_SH@@', "$filter" ];
    IPC::Run3::run3($cmd, $src, $dst, undef);
}

sub __filter_shell_inline {
    my ($filter, $src, $dst) = @_;
    my ($cmd);

    if (!dewi_got_feature('external_filters')) {
        print "Cannot run `shell-inline' filter as required.\n";
        print "This dewi has no support for external filters. Giving up.\n";
        return 1;
    }
    return 1 if (get_opt_bool('dryrun'));
    $cmd = [ '@@POSIX_SH@@', '-c', "$filter" ];
    IPC::Run3::run3($cmd, $src, $dst, undef);
}

sub __filter {
    my ($filter, $type, $src, $dst) = @_;

    if ($type eq 'perl') {
        __filter_perl($filter, $src, $dst)
    } elsif ($type eq 'shell-file') {
        __filter_shell_file($filter, $src, $dst)
    } elsif ($type eq 'shell-inline') {
        __filter_shell_inline($filter, $src, $dst)
    } else {
        die "__filter(): Unknown filter type `$type'\n";
    }
}

sub method_filtered {
    my ($src, $dst, $filter, $type) = @_;
    my ($dstat, $sstat);

    $sstat = xstat($src);
    $dstat = xstat($dst);
    if (($dstat->{exist} == 1) && ($sstat->{ino} == $dstat->{ino})) {
        die "  _filtered(): $src and $dst are the same file. Please resolve!\n";
    }
    if ((!get_opt_bool('filter_always'))
            && ($dstat->{exist} == 1) && ($sstat->{mtime} <= $dstat->{mtime}))
    {
        verbose("  _filtered(): $dst (source is not newer, skipping)\n");
        debug("       source: $src\n");
        return 1;
    }
    verbose("  _filtered(): $dst\n");
    debug("       source: $src\n");
    __filter($filter, $type, $src, $dst);
}

sub method_force_copy {
    my ($src, $dst, $dummy0, $dummy1) = @_;
    my ($dstat, $sstat);

    $sstat = xstat($src);
    $dstat = xstat($dst);
    if (($dstat->{exist} == 1) && ($sstat->{ino} == $dstat->{ino})) {
        die
        "  _force_copy(): $src and $dst are the same file. Please resolve!\n";
    }
    verbose("  _force_copy(): $dst\n");
    debug("         source: $src\n");
    xcopy($src, $dst);
}

sub method_hardlink {
    my ($src, $dst, $dummy0, $dummy1) = @_;
    my ($dstat, $sstat);

    $sstat = xstat($src);
    $dstat = xstat($dst);
    if (($dstat->{exist} == 1) && ($sstat->{ino} == $dstat->{ino})) {
        verbose("  _hardlink(): $dst (hardlinked to source, skipping)\n");
        debug("       source: $src\n");
        return 1;
    }
    verbose("  _hardlink(): $dst\n");
    debug("       source: $src\n");
    xhardlink($src, $dst);
}

sub method_symlink {
    my ($src, $dst, $dummy0, $dummy1) = @_;
    my ($not_a_symlink);

    if (-l $dst) {
        $not_a_symlink = 0;
        my ($sstat, $tstat, $t);
        $t = readlink $dst or die "  _symlink(): readlink() failed: $!\n";
        $tstat = xstat($t);
        $sstat = xstat($src);
        if (($tstat->{exist} == 1) && ($tstat->{ino} == $sstat->{ino})) {
            verbose("  _symlink(): $dst (symlinked to source, skipping)\n");
            debug("      source: $src\n");
            return 1;
        }
    } else {
        $not_a_symlink = 1;
    }

    if ($not_a_symlink && -e $dst) {
        die
        "  _symlink(): destination $dst exists but is not a symlink.\n" .
        "              Please resolve!\n";
    }
    verbose("  _symlink(): $dst\n");
    debug("      source: $src\n");
    xsymlink($src, $dst);
}

sub deploy_files {
    my ($base) = @_;

    run_hook('pre-deploy', \$base);
    print "Deploying $base...\n";
    foreach my $f (@regfiles) {
        ensure_dir($f->{destination});
        if (defined $f->{deploydir} && $f->{deploydir} eq 'yes') {
            next;
        }
        $methods{$f->{method}}->(
            $f->{path},
            $f->{mergedname},
            $f->{filter},
            $f->{filtertype});
    }
    run_hook('post-deploy', \$base);
}

sub withdraw_files {
    my ($base) = @_;
    my (%dests);

    run_hook('pre-withdraw', \$base);
    print "Withdrawing $base...\n";
    foreach my $f (@regfiles) {
        if (!defined $dests{$f->{destination}}) {
            $dests{$f->{destination}} = 'xxx';
        }
        if (defined $f->{deploydir} && $f->{deploydir} eq 'yes') {
            next;
        }
        if (!-e $f->{mergedname}) {
            verbose("  withdraw: " . $f->{mergedname}
                . " does not exist. Ignoring.\n");
        } else {
            verbose("  withdraw: unlink(" . $f->{mergedname} . ")\n");
            xunlink($f->{mergedname});
        }
    }

    foreach my $d (sort { length $b <=> length $a } keys %dests) {
        if (!-d $d) {
            verbose("  withdraw: $d does not exist. Ignoring.\n");
            next;
        }
        if (Cwd::realpath($d) eq Cwd::realpath($ENV{HOME})) {
            # no, we're not removing ~.
            next;
        }
        if (get_opt_bool('dryrun')) {
            verbose("  dryrun: Test if $d is empty and if so remove it.\n");
        } elsif (xdir_is_empty($d)) {
            verbose(
                "  withdraw: rmdir($d) (empty directory)\n");
            xrmdir($d);
        } else {
            verbose("  withdraw: `$d' is not empty. Leaving it alone.\n");
        }
    }
    run_hook('post-withdraw', \$base);
}

# archiving
sub __gen_archive_name {
    my ($dest) = @_;
    my ($format, $rc);

    $format = get_opt('archive-format');
    if (!defined $format) {
        $format = '%s';
    }
    if ($format =~ m/\%s/) {
        $rc = sprintf $format, $DEWI{PACKAGE};
    } else {
        $rc = $format;
    }
    return expand_dir($dest . '/' . $rc . '.tar');
}

sub __gen_tmp_dir {
    if (defined $ENV{TMPDIR} && $ENV{TMPDIR} ne '') {
        return $ENV{TMPDIR};
    }
    return '/tmp';
}

sub __gen_dir_name {
    my ($tmpdir);
    my ($format, $rc);

    $tmpdir = __gen_tmp_dir();
    $format = get_opt('archive-dir-format');
    if (!defined $format) {
        $format = 'dewi/%s';
    }
    if ($format =~ m/\%s/) {
        $rc = sprintf $format, $DEWI{PACKAGE};
    } else {
        $rc = $format;
    }
    return $tmpdir . '/' . $rc;
}

sub __prepare_archive {
    my ($dir) = @_;

    ensure_dir($dir);
    foreach my $f (qw{ Dewifile Makefile }) {
        xcopy($DEWI{BASE_DIR} . '/' . $DEWI{PACKAGE} . '/' . $f,
              $dir . '/' . $f);
    }
    foreach my $f (@regfiles) {
        if (defined $f->{deploydir} && $f->{deploydir} eq 'yes') {
            next;
        }
        my ($src, $dstdir, $dstfile);
        $src = $f->{path};
        $dstdir = $dir . '/' . $f->{srcdir};
        $dstfile = $dstdir . '/' . $f->{name};

        ensure_dir($dstdir);
        xcopy($src, $dstfile);
    }
}

sub __tar {
    my ($dir, $file) = @_;
    my ($rc);

    $rc = run_dot_dewi_script('/bin/tar.sh', $dir, $file);
    if ($rc != 0) {
        die "tar(): Could not create \"$file\" from \"$dir\".\n";
    }
}

sub __prepare_and_tar {
    my ($dest, $mode) = @_;
    my ($dir, $file, $tmpdir);

    $file = __gen_archive_name($dest);
    $dir = __gen_dir_name();
    verbose("Creating archive: '$file$mode'\n");
    __prepare_archive($dir);
    __tar($dir, $file);
    return ($dir, $file);
}

sub __clean_up_archive_dir {
    my ($dir) = @_;
    my ($rc);

    $rc = run_dot_dewi_script('/bin/rmrf.sh', $dir);
    if ($rc != 0) {
        die "tar(): Could not remove \"$dir\".\n";
    }
}

sub __gzip_file {
    my ($file) = @_;
    my ($rc);

    $rc = run_dot_dewi_script('/bin/gzip.sh', $file);
    if ($rc != 0) {
        die "tar(): Could not gzip \"$file\".\n";
    }
}

sub __bzip2_file {
    my ($file) = @_;
    my ($rc);

    $rc = run_dot_dewi_script('/bin/bzip2.sh', $file);
    if ($rc != 0) {
        die "tar(): Could not bzip2 \"$file\".\n";
    }
}

sub tar {
    my ($base) = @_;
    my ($dest, $dir, $file);

    return 0 if (!defined $archives{tar});
    $dest = $archives{tar};
    ($dir, $file) = __prepare_and_tar($dest, '');
    __clean_up_archive_dir($dir);
}

sub tar_gz {
    my ($base) = @_;
    my ($dest, $dir, $file);

    return 0 if (!defined $archives{'tar-gz'});
    $dest = $archives{'tar-gz'};
    ($dir, $file) = __prepare_and_tar($dest, '.gz');
    __clean_up_archive_dir($dir);
    __gzip_file($file);
}

sub tar_bz2 {
    my ($base) = @_;
    my ($dest, $dir, $file);

    return 0 if (!defined $archives{'tar-bz2'});
    $dest = $archives{'tar-bz2'};
    ($dir, $file) = __prepare_and_tar($dest, '.bz2');
    __clean_up_archive_dir($dir);
    __bzip2_file($file);
}

# hooks
sub register_hook {
    my ($event, $hr) = @_;

    push @{ $hooks{$event} }, $hr;
    return 1;
}

sub run_shell_hook_file {
    my ($ev, $file, @args) = @_;
    my (@cmd);

    push @cmd, '@@POSIX_SH@@';
    foreach my $scal (@args) {
        push @cmd, $$scal;
    }
    $ENV{DEWI_HOOK_EVENT} = $ev;
    system(@cmd);
    delete($ENV{DEWI_HOOK_EVENT});
}

sub run_shell_hook_inline {
    my ($ev, $code, @args) = @_;
    my (@env_args, $i);

    $ENV{DEWI_HOOK_EVENT} = $ev;
    $i = 0;
    foreach my $scal (@args) {
        push @env_args, "DEWI_HOOK_ARG$i";
        $ENV{"DEWI_HOOK_ARG$i"} = $$scal;
        $i++;
    }
    system(('@@POSIX_SH@@', '-c', $code));
    delete($ENV{DEWI_HOOK_EVENT});
    foreach my $key (@env_args) {
        delete($ENV{$key});
    }
}

sub run_hook {
    # The @args should be a set of scalar references. They *must* be references,
    # in fact, because `run_shell_hook_file()' dereferences them before passing
    # the scalars as arguments to the script file. `run_shell_hook_inline()'
    # behaves similarly.
    my ($event, @args) = @_;

    if (!defined $hooks{$event} || scalar @{ $hooks{$event} } == 0) {
        return 0;
    }

    foreach my $h (@{ $hooks{$event} }) {
        if ($h->{type} eq 'perl') {
            $h->{code}->($event, @args);
        } elsif ($h->{type} eq 'shell-file') {
            run_shell_hook_file($event, $h->{code}, @args);
        } elsif ($h->{type} eq 'shell-inline') {
            run_shell_hook_inline($event, $h->{code}, @args);
        } else {
            die "BUG: Unknown hook type: " . $h->{type} . ". Giving up.\n";
        }
    }

    return 1
}

# signals
$SIG{INT} = sub {
    print "Got SIGINT. Exiting failing, as requested.\n";
    exit 1;
};

$SIG{HUP} = sub {
    print "Got SIGHUP. Exiting succeeding, as requested.\n";
    exit 0;
};

# the main() routine
sub main {
    if ($#ARGV < 0) {
        die "usage: dewi.pl <mode> [options]\n";
    }
    my $mode = $ARGV[0];
    my $cwd = Cwd::cwd();
    my @dirs = File::Spec->splitdir($cwd);
    my $base = $dirs[-1];
    defaults();

    if ($mode eq 'deploy' || $mode eq 'withdraw'
            || $mode =~ m/^archive(s|-tar(|-gz|-bz2))$/)
    {
        set_dewi_hash();
        DewiFile::read_dewifile('../.dewi/config.perl') or return 1;
        DewiFile::read_dewifile('Dewifile') or return 1;
    }

    if (get_opt_bool('dryrun')) {
        print "dewi: --- This is a dry run ---\n";
    }

    if ($mode eq 'deploy') {
        deploy_files($base);
    } elsif ($mode eq 'withdraw') {
        withdraw_files($base);
    } elsif ($mode eq 'archives') {
        tar_gz($base);
        tar_bz2($base);
        # `tar' must be last, otherwise the .tar file may be reused and removed.
        tar($base);
    } elsif ($mode eq 'archive-tar') {
        tar($base);
    } elsif ($mode eq 'archive-tar-gz') {
        tar_gz($base);
    } elsif ($mode eq 'archive-tar-bz2') {
        tar_bz2($base);
    } elsif ($mode eq 'parent_help') {
        parent_help();
    } elsif ($mode eq 'child_help') {
        child_help();
    } else {
        die "Unknown mode of operation: \"$mode\".\n";
    }

    return 0;
}
exit main();
