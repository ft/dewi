#!/usr/bin/perl

# This is an example hook, which removes dead symlinks.
#
# Say, a setup reads all files from a certain directory and these file names
# may change. That could lead to dead symbolic links with consecutive
# deployments.
#
# In my case, my zsh configuration basically reads all "*.z" files from
# "~/.zshrc.d/". Those file names start with four digits to control the
# order in which the files are loaded. If I'd like to change the order, I
# need to change a file name. When I deploy the setup again, I'll end up
# with a dead link.
#
# Here's how it works:
#
# # First, we need to tell the system where to look for dead links:
# nuke_deadlinks_register('~/.zshrc.d', '*.z');
#
# # Then we need to register the hook. `pre-deploy' make sense; `pre-withdraw'
# # might make sense for you too. Or anything else. Your choice.
# add_hook( { type  => 'perl',
#             event => 'pre-deploy',
#             code  => \&nuke_deadlinks } );

my (%__nuke_deadlinks);

sub nuke_deadlinks_register {
    my ($dir, $glob) = @_;

    if (!defined $dir || !defined $glob) {
        die "Usage: nuke_deadlinks_register('<dir>', '<glob>');\n";
    }
    $__nuke_deadlinks{$dir} = $glob;
    return 1;
}

sub nuke_deadlinks {
    my ($odir);

    use Cwd;
    $odir = cwd();
    DIR: foreach my $dir (sort keys %__nuke_deadlinks) {
        my $key = $dir;
        $dir =~ s!^~!$ENV{HOME}!;
        $dir =~ s/\/+$//;
        chdir($dir) or do { warn "Couldn't change to $dir!\n";
                            next DIR; };
        print "Nuking dead symbolic links in $dir/...\n";
        my @dls = grep { -l && ! -e } bsd_glob($__nuke_deadlinks{$key});
        foreach my $dl (sort @dls) {
            print "  nuke_deadlinks(): Removing dead link: $dl\n";
            unlink $dl || print "    Failed to remove dead link!\n";
        }
        chdir($odir) or die "Couldn't change to $odir!\n";
    }
    return 1;
}

end();
